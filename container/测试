
多测试而非调试
传统测试

assertEquals(3,add(1,2)) 期待值,计算值

这个方法将测试逻辑与结果混在一起

如果报了出错 那么需要去看是参数错误还是算法错误 出错信息不明确  而且一旦一个数据出错 测试全部结束

------------------------------------------------------------------------------------------------

表格驱动测试

参数和结果通过表格的形式写在一起

数组test
{1,2,3},
{0,2,2},
....

actual:=add(test.a,test.b);

分离测试数据和逻辑

可以部分失败


BenchMark性能测试


------------------------------------------------------------------------------------------------
命令行

go test .  将当前目录所有测试运行一遍
执行时会读取-cpu标记的值并转换为int类型的切片[1,2,4] 迭代切片执行  如果没有标记则转换为[最大CPU核心数]默认的切片



go test -coverprofile=c.out 将覆盖率情况写到c.out文件里

go tool cover -html=c.out  将覆盖率结果转为html查看

go  test -bench .  将目录所有测试 执行性能测试

go test -bench . -cpuprofile cpu.out  将性能测试的cpu结果输出 cpu.out为二进制文件

go tool pprof cpu.out  出现交互式命令行   再输入web可以在网页上看到 各个部分的执行时间 方框越大耗时越多

go clean -testcache 清除测试结果缓存

-cpu XX 设置最大cpu核心数量  一台计算机的cpu核心个数 代表它同一时刻能同时多少条命令
一个P核心能承载多个goroutine（用户级线程） 而这些G能跟Machine(系统级线程)进行对接
每个核心维持一个goroutine队列

此标志可以模拟不同核心下的程序运算能力

-count XX
在不同最大数量P的数量下 分别重复执行5此


一个性能函数测试执行的次数=-cpu个数*-count个数*探索式循环执行的个数
一个功能测试函数执行的次数=-cpu个数*-count个数



------------------------------------------------------------------------------------------------

测试分为

对单一的功能模块进行边界清晰的测试，并且不掺杂任何对外部环境的检测
极客时间版权所有: https://time.geekbang.org/column/article/41255
单元测试（程序员必做的自我检查） 测试文件与测试函数在同个包内 文件名 *_test.go 测试文件中的测试函数 可以根据逻辑进行分组 根据先后顺序进行排序

包括
1.功能测试 test            函数名 Test*  (t *testing.T)||  testing.T 具有功能   判定失败接口(t.Fail 失败继续执行,t.FailNow 失败结束)，打印测试日志
2.性能测试 benchmark       函数名 Benchmark*  (b *testing.B)
testing.B 具有功能 拥有testing.T 的全部接口，同时还可以统计内存消耗，指定并行数目和操作计时器等
B.N 当循环执行这个时候 B.N先为1   函数的执行时机<上限值 (1S) 会增大B.N 直到执行时机超过上限值 循环结束
benchmark的执行次数是被测函数的执行次数 不是测试函数的执行次数

使用pprof进行优化
3.示例测试 example         函数名 Example*  (任何)


API测试 HTTP SERVER测试
集成测试
灰度测试


一个测试用例 大多数情况下 一个仅用一个测试函数即可

通常用来描述 程序的某方面功能 什么样的输入有什么样的输出 该功能什么情况下报错或表现异常




go test 命令行会做哪些操作？

1.准备工作

检查1.测试源码文件命名
    2.测试函数命名与签名(类似c++ 方法的唯一标识)
    3.标记是否合法


2.构建工作

依次构建 执行包中符合要求的测试函数 清理临时文件 打印测试结果

并发进行功能测试 结果按照执行顺序返回 (执行并发 返回串行)

构建完成后通常会缓存结果 一旦出现任何变动 缓存数据就会失效  失败的测试不会缓存























